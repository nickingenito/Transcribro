import { useEffect, useState } from "react";
import { useTranscription } from "src/context/TranscriptionContext";
import useProcessVTT from "src/hooks/useProcessVtt";

function convertToBGR(hexColor: any) {
    hexColor = hexColor.replace("#", "");
    let bgrColor
    if (hexColor === "FF"){
      bgrColor = "FFFFFFFF";
    } else {
      let red = hexColor.substr(0, 2);
      let green = hexColor.substr(2, 2);
      let blue = hexColor.substr(4, 2);
      bgrColor = blue + green + red;
    }

    // Return the BGR color in ASS format
    return `&H${bgrColor}`;
}
  
const useGenerateASS = () => {
  const {
    fontSize,
    fontStyle,
    fontColor,
    transcriptionVTT,
    isBold,
    isItalic,
    isUnderline,
    videoHighlightColors,
    textStroke,
    textShadow,
  } = useTranscription();
  const { processVTTString, processedVTT } = useProcessVTT({
    fontSize,
    fontStyle,
    fontColor: convertToBGR(fontColor),
  });
  const [assFile, setAssFile] = useState<File | null>(null);
  const bgrFontColor = convertToBGR(fontColor);
  const bgrVideoHighlightColors = convertToBGR(videoHighlightColors);
  const bgrTextStroke = convertToBGR(textStroke);
  useEffect(() => {
    processVTTString(transcriptionVTT!);
  }, [transcriptionVTT, processVTTString]);

  useEffect(() => {
    if (processedVTT) {
      // Split the processed VTT content into individual subtitle entries
      const subtitles = processedVTT.split("\n\n").map(entry => entry.trim());
      const assStyles = `[Script Info]
Script generated by FFmpeg
ScriptType: v4.00+
ScaledBorderAndShadow: yes
PlayResY: {yres}
PlayResX: {xres}
WrapStyle: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, Bold, Italic, Underline, StrikeOut, OutlineColour, BackColour, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, MarginL, MarginR, MarginV, Encoding
Style: Default,${fontStyle},${fontSize},${bgrFontColor},${isBold ? "-1" : "0"},${isItalic ? "-1" : "0"},${isUnderline ? "-1" : "0"},0,${bgrTextStroke},${bgrVideoHighlightColors},100,100,0,0,0,2,${(textShadow === "" || "none") ? "0" : "1"},100,100,100,1
\n[Events]\nFormat: Start, End, Style, Text`;
      const assLines = subtitles
      .filter(subtitle => !subtitle.startsWith("WEBVTT"))
      .map((subtitle, index) => {
        // Extract the timestamp and text from each subtitle entry
        const [timestampLine, ...textLines] = subtitle.split("\n");
        const [start, end] = timestampLine.split(" --> ").map(time => {
          const [hh, mm, ssms] = time.split(":");
          const formattedSSMS = ssms.slice(0, -1); // Remove the last 0 from milliseconds
          return `${parseInt(hh, 10)}:${mm}:${formattedSSMS}`;
        });
        const text = textLines.join("\\N");
        return `Dialogue: ${start}, ${end},Default,{\\pos({x},{y})}${text}`;
      })
      .join("\n");
      // Combine styles and dialogue lines to form the complete ASS content
      const assContent = `${assStyles}\n${assLines}`;
      const blob = new Blob([assContent], { type: "text/plain" });
      const assFile = new File([blob], "captions.ass", { type: "text/plain" });
      setAssFile(assFile);
    }
  }, [processedVTT, fontSize, fontStyle, fontColor, isBold, isItalic, isUnderline]);

  return assFile;
};

export default useGenerateASS;